# -*- coding: utf-8 -*-
"""Mavlink interface (mavlink_vehicle_link.py) tests."""
import pytest
import math
from unittest.mock import patch, Mock
from time import time, sleep
from pymavlink import mavutil
from rov_multiserver.mavlink_vehicle_link import MavlinkVehicleLink
from rov_multiserver.vehicle_data import VehicleNavigationMode


@pytest.fixture
def not_connected_vehicle_link(event_loop):
    """
    A MavlinkVehicleLink object with a mocked Mavlink connection.

    This fixture doesn't call connect() before passing to the test.

    Yields
    ------
    tuple
        A tuple with a MavlinkVehicleLink object ready for tests (the
        element that actually connects with a real device is patched, so
        no real connection to any real device is possible) as its first
        element, the mock that is patching the mavlink connection
        method as the second element (to conveniently apply
        "return_value" or "side_effect" on tests) and the mavlink
        message mock as the third element.

    """
    # vehicle_link, mavlink_factory_mock, fake_message, patcher\
    #     = _vehicle_link_creation()
    patcher = patch('rov_multiserver.mavlink_vehicle_link.'
                    'mavutil.mavlink_connection')
    fake_mavlink = Mock(name='mavlink')
    fake_heartbeat_msg = Mock(name='heartbeat message')
    fake_mavlink.wait_heartbeat.return_value = fake_heartbeat_msg
    fake_heartbeat_msg.get_type = Mock(return_value='HEARTBEAT')
    fake_heartbeat_msg.to_dict = Mock(
        return_value={'mavpackettype': 'HEARTBEAT',
                      'data': 'doesn\'t matter here!'})
    # fake mavlink recv_match returns a fake message
    fake_message = Mock(name='msg')
    fake_mavlink.recv_match = Mock(return_value=fake_message)
    # fake mavlink factory returns the mavlink mock.
    mavlink_factory_mock = patcher.start()
    mavlink_factory_mock.return_value = fake_mavlink
    vehicle_link = MavlinkVehicleLink()
    yield (vehicle_link, mavlink_factory_mock, fake_message)
    vehicle_link.stop(wait=True)
    # if vehicle_link._connected:
    #     vehicle_link.disconnect()
    # if vehicle_link._loop.is_running():
    #     vehicle_link._loop.call_soon_threadsafe(vehicle_link._loop.stop)
    # while vehicle_link._loop.is_running():
    #     pass
    patcher.stop()


@pytest.fixture
def connected_vehicle_link(not_connected_vehicle_link):
    """TODO: Document."""
    vehicle_link_fixture = not_connected_vehicle_link
    vehicle_link_fixture[0].start(force_now=True)
    while not vehicle_link_fixture[0]._connected:
        pass
    # vehicle_link_fixture[0].connect('127.0.0.1', 5000)
    return vehicle_link_fixture


@patch('rov_multiserver.mavlink_vehicle_link.event_bus')
def test_do_acquire_data(fake_bus, not_connected_vehicle_link):
    """
    Tests the return values of _do_acquire_data().

    1.  Connect but patching the telemetry automatic threads.
    2.  When the message hasn't a "get_type()" method, it should not
        raise any exception and just return None. (TODO: maybe a warning
        here should be fine on the future).
    3.  An non-string get_type() value should returns a None.
    4.  An non-tracked get_type() value should returns a None.
    5.  A tracked message type should return the dict generated by
        the to_dict() method and should trigger a 'new-vehicle-message'
        event on the event bus, passing the same dict as the callback
        input argument.

    Parameters
    ----------
    not_connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle, _, fake_message = not_connected_vehicle_link
#    with patch.object(vehicle, 'start_telemetry'):
    vehicle.connect('127.0.0.1', 5000)
    fake_message.get_type = Mock(side_effect=AttributeError)
    try:
        acquire_response = vehicle._do_acquire_data()
    except BaseException as real_exception:
        pytest.fail("A _do_acquire_data() call failed with: "
                    "{exception}".format(exception=type(
                        real_exception).__name__))
    assert acquire_response is None
    fake_message.get_type = Mock(return_value=12345)
    assert vehicle._do_acquire_data() is None
    fake_message.get_type = Mock(return_value='NON-TRACKED-TYPE')
    assert vehicle._do_acquire_data() is None
    fake_message.get_type = Mock(return_value='HEARTBEAT')
    fake_message.to_dict = Mock(
        return_value={'mavpackettype': 'HEARTBEAT',
                      'data': 'doesn\'t matter here!'})
    fake_bus.trigger.reset_mock()
    assert not fake_bus.trigger.called
    before_acquire_time = time()
    acquire_response = vehicle._do_acquire_data()
    after_acquire_time = time()
    assert fake_bus.trigger.called
    assert len(fake_bus.trigger.call_args[0]) == 3
    assert fake_bus.trigger.call_args[0][0] == 'new-vehicle-message'
    msg_dict = fake_bus.trigger.call_args[0][1]
    timestamp = fake_bus.trigger.call_args[0][2]
    assert isinstance(msg_dict, dict)
    assert msg_dict.get('mavpackettype') == 'HEARTBEAT'
    assert msg_dict.get('data') == 'doesn\'t matter here!'
    assert isinstance(timestamp, (float, int))
    assert timestamp >= before_acquire_time
    assert timestamp <= after_acquire_time
    assert acquire_response is not None
    assert isinstance(acquire_response, dict)
    assert 'mavpackettype' in acquire_response
    assert acquire_response.get('mavpackettype') == 'HEARTBEAT'
    vehicle._vehicle.recv_match.return_value = None
    assert vehicle._do_acquire_data() is None


def test_do_process_data(not_connected_vehicle_link):
    """
    Test of _do_process_data() method.

    1.  Connects the patched "MavlinkVehicleLink".
    2.  Check if passing an int, str or list should raise TypeError.
    3.  Check if passing a dict without the "mavpackettype" field should
        raise ValueError.
    4.  Passing a SYS_STATUS message with 'voltage_battery' and
        'current_battery' fields should update the vehicle.telemetry
        corresponding attributes.
    5.  Passing an ATTITUDE message with 'pitch', 'roll', 'yaw',
        'pitchspeed', 'rollspedd' and 'yawspeed' fields should update
        the vehicle.telemetry corresponding attributes.
    6.  Passing a SCALED_PRESSURE2 message with a 'press_abs' field
        should update the vehicle.telemetry.pressure attribute.
    7.  Passing a STATUSTEXT message with a 'Leak Detected' text should
        set the vehicle.state.leak_detected flag.

    Parameters
    ----------
    not_connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle = not_connected_vehicle_link[0]
#    with patch.object(vehicle, 'start_telemetry'):
    vehicle.connect('127.0.0.1', 5000)
    with pytest.raises(TypeError):
        vehicle._do_process_data(1)
    with pytest.raises(TypeError):
        vehicle._do_process_data('asd')
    with pytest.raises(TypeError):
        vehicle._do_process_data([])
    with pytest.raises(ValueError):
        vehicle._do_process_data({'non-mavpackettype-field': 'asd'})
    # Test Voltage and Current Measurements (SYS_STATUS message)
    voltage = 14.2  # in Volts
    current = 335.62  # in mA
    assert pytest.approx(vehicle.telemetry.
                         voltage.get_volts()) != voltage
    assert pytest.approx(vehicle.telemetry.
                         current.get_milliamperes()) != current
    vehicle._do_process_data({'mavpackettype': 'SYS_STATUS',
                              'voltage_battery': voltage * 1000.0,  # V -> mV
                              'current_battery': current / 10.0})  # mA -> cA
    assert pytest.approx(vehicle.telemetry.
                         voltage.get_volts()) == voltage
    assert pytest.approx(vehicle.telemetry.
                         current.get_milliamperes()) == current
    # Test orientation measurements (ATTITUDE message)
    pitch = 34.6
    roll = 134.72
    yaw = -7.6
    pitch_speed = 0.06
    roll_speed = 0.002
    yaw_speed = 27.836
    assert pytest.approx(vehicle.telemetry.pitch.get_degrees()) != pitch
    assert pytest.approx(vehicle.telemetry.roll.get_degrees()) != roll
    assert pytest.approx(vehicle.telemetry.yaw.get_degrees()) != yaw
    assert pytest.approx(vehicle.telemetry.
                         pitch_speed.get_degrees_s()) != pitch_speed
    assert pytest.approx(vehicle.telemetry.
                         roll_speed.get_degrees_s()) != roll_speed
    assert pytest.approx(vehicle.telemetry.
                         yaw_speed.get_degrees_s()) != yaw_speed
    vehicle._do_process_data({'mavpackettype': 'ATTITUDE',
                              'pitch': math.radians(pitch),
                              'roll': math.radians(roll),
                              'yaw': math.radians(yaw),
                              'pitchspeed': math.radians(pitch_speed),
                              'rollspeed': math.radians(roll_speed),
                              'yawspeed': math.radians(yaw_speed)})
    assert pytest.approx(vehicle.telemetry.pitch.get_degrees()) == pitch
    assert pytest.approx(vehicle.telemetry.roll.get_degrees()) == roll
    assert pytest.approx(vehicle.telemetry.yaw.get_degrees()) == yaw
    assert pytest.approx(vehicle.telemetry.
                         pitch_speed.get_degrees_s()) == pitch_speed
    assert pytest.approx(vehicle.telemetry.
                         roll_speed.get_degrees_s()) == roll_speed
    assert pytest.approx(vehicle.telemetry.
                         yaw_speed.get_degrees_s()) == yaw_speed
    # Test pressure measurements (SCALED_PRESSURE2)
    pressure = 23.678  # bar
    assert pytest.approx(vehicle.telemetry.pressure.get_bar()) != pressure
    vehicle._do_process_data({'mavpackettype': 'SCALED_PRESSURE2',
                              'press_abs': pressure * 1000})  # mbar
    assert pytest.approx(vehicle.telemetry.pressure.get_bar()) == pressure
    # Test leak warning
    assert not vehicle.state.leak_detected
    vehicle._do_process_data({'mavpackettype': 'STATUSTEXT',
                              'text': 'Leak Detected'})
    assert vehicle.state.leak_detected


@patch('rov_multiserver.mavlink_vehicle_link.event_bus')
def test_connect(fake_bus, not_connected_vehicle_link):
    """
    Tests the connect() method with various valid and invalid arguments.

    1.  Calling with a string on the port, a float on the host or a int
        in the host should raise TypeError.
    2.  Calling with an invalid hostname (which can't be resolver), or
        an invalid port (out of range) should raise ValueError.
    3.  Calling with host: 127.0.0.1 (or just "localhost") and port
        15000 should generate an internal call to mavutil_connection()
        with "udpin:127.0.0.1:15000".
    4.  Every succesful connect() call should trigger a
        'vehicle-connected' event on the event bus.
    5.  Every disconnect() call should trigger a 'vehicle-disconnected'
        event on the event bus.
    6.  The connect method should return a boolean indicating if the
        connection was succesful.
    7.  In the case of mavlink it's tested using the "wait_heartbeat()"
        method with a timeout of 1.5 secs (It should report a heartbeat
        with a frequency of 1 Hz).

    Parameters
    ----------
    not_connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle, mavlink_factory_mock, _ = not_connected_vehicle_link
    for input_args in [('127.0.0.1', '15000'),
                       (127.0, 15000),
                       (127, 15000)]:
        with pytest.raises(TypeError):
            vehicle.connect(*input_args)
    for input_args in [('foo', 15000),
                       ('127.0.0.1', 65536)]:
        with pytest.raises(ValueError):
            vehicle.connect(*input_args)
    mavlink_factory_mock.reset_mock()
    assert not mavlink_factory_mock.called
    assert not fake_bus.trigger.called
    connect_result = vehicle.connect('127.0.0.1', 15000)
    assert fake_bus.trigger.called
    assert len(fake_bus.trigger.call_args[0]) == 2
    assert fake_bus.trigger.call_args[0][0] == 'vehicle-connected'
    assert fake_bus.trigger.call_args[0][1] == '127.0.0.1:15000'
    assert mavlink_factory_mock.called
    assert mavlink_factory_mock.call_args[0][0] == 'udpin:127.0.0.1:15000'
    assert connect_result is True
    fake_bus.trigger.reset_mock()
    assert not fake_bus.trigger.called
    vehicle.disconnect()
    assert fake_bus.trigger.called
    assert len(fake_bus.trigger.call_args[0]) == 1
    assert fake_bus.trigger.call_args[0][0] == 'vehicle-disconnected'
    mavlink_factory_mock.reset_mock()
    assert not mavlink_factory_mock.called
    fake_bus.trigger.reset_mock()
    assert not fake_bus.trigger.called
    connect_result = vehicle.connect('localhost', 15000)
    assert fake_bus.trigger.called
    assert len(fake_bus.trigger.call_args[0]) == 2
    assert fake_bus.trigger.call_args[0][0] == 'vehicle-connected'
    assert fake_bus.trigger.call_args[0][1] == '127.0.0.1:15000'
    assert mavlink_factory_mock.called
    assert mavlink_factory_mock.call_args[0][0] == 'udpin:127.0.0.1:15000'
    assert connect_result is True
    vehicle.disconnect()
    # Test connection failure
    vehicle._vehicle.wait_heartbeat.return_value = None
    fake_bus.trigger.reset_mock()
    connect_result = vehicle.connect('localhost', 15000)
    assert not fake_bus.trigger.called
    assert connect_result is False


def assert_set_servo_call(vehicle, channel, pwm_value):
    """
    Assertion of command_long_send() checking channel and pwm_value.

    Parameters
    ----------
    vehicle : MavlinkVehicleLink
        Patched MavlinkVehicleLink object
    channel : int
        PWM channel
    pwm_value : int
        PWM value

    """
    assert vehicle._vehicle.mav.command_long_send.call_args[0][4] == channel
    assert vehicle._vehicle.mav.command_long_send.call_args[0][5] == pwm_value


def test_light_methods(connected_vehicle_link):
    """
    Tests the light related methods in various scenarios.

    Test scenarios:
    ---------------

    1.  set_light() with a str argument should raise TypeError.
    2.  set_light() with an intensity > 100 should raise ValueError.
    3.  Before properly call set_light(), get_light() and
        state.lights.level should be 0.0.
    4.  After calling set_light(50), get_light() and state.lights.level
        should be 50.0. Moreover, the mavlink command_long_send() method
        should be called with channel 9 and with 1500us for PWM.
    5.  After calling set_light(100), get_light() and state.lights.level
        should be 100.0. Moreover, the mavlink command_long_send() method
        should be called with channel 9 and with 1900us for PWM.

    Parameters
    ----------
    connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle = connected_vehicle_link[0]
    with pytest.raises(TypeError):
        vehicle.set_light('100')
    with pytest.raises(ValueError):
        vehicle.set_light(100.0001)
    assert vehicle.get_light() == 0.0
    assert vehicle.state.lights_level == 0.0
    vehicle.set_light(50)  # 50% = 1500 us
    assert_set_servo_call(vehicle, 9, 1500)
    assert vehicle.get_light() == 50.0
    assert vehicle.state.lights_level == 50.0
    vehicle.set_light(100)  # 100% = 1900 us
    assert_set_servo_call(vehicle, 9, 1900)
    assert vehicle.get_light() == 100.0
    assert vehicle.state.lights_level == 100.0


def test_cam_tilt_methods(connected_vehicle_link):
    """
    Tests the camera tilt related methods in various scenarios.

    Test scenarios:
    ---------------

    1.  set_camera_tilt() with a str argument should raise TypeError.
    2.  set_camera_tilt() with an angle > 45 should raise ValueError.
    3.  Before properly call set_camera_tilt(), state.cam_tilt_angle
        should be 0.0.
    4.  After calling set_camera_tilt(45), state.cam_tilt_angle should
        be 45.0. Moreover, the mavlink command_long_send() method
        should be called with channel 10 and with 1900us for PWM.
    5.  After calling set_camera_tilt(-45), state.cam_tilt_angle should
        be -45.0. Moreover, the mavlink command_long_send() method
        should be called with channel 10 and with 1100us for PWM.
    6.  After calling straighten_the_camera(), state.cam_tilt_angle
        should be 0.0. Moreover, the mavlink command_long_send() method
        should be called with channel 10 and with 1500us for PWM.

    Parameters
    ----------
    connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle = connected_vehicle_link[0]
    with pytest.raises(TypeError):
        vehicle.set_camera_tilt('45')
    with pytest.raises(ValueError):
        vehicle.set_camera_tilt(45.0001)
    assert vehicle.state.cam_tilt_angle == 0.0
    vehicle.set_camera_tilt(45)  # 45° = 1900 us
    assert_set_servo_call(vehicle, 10, 1900)
    assert vehicle.state.cam_tilt_angle == 45.0
    vehicle.set_camera_tilt(-45)  # -45° = 1100 us
    assert_set_servo_call(vehicle, 10, 1100)
    assert vehicle.state.cam_tilt_angle == -45.0
    vehicle.straighten_the_camera()
    assert_set_servo_call(vehicle, 10, 1500)
    assert vehicle.state.cam_tilt_angle == 0.0


def assert_set_mode_with_id(vehicle, mode_id):
    """
    Assertion of set_mode_send() checking mode id.

    Parameters
    ----------
    vehicle : MavlinkVehicleLink
        Patched MavlinkVehicleLink object
    mode_id : int
        Corresponding mode ID code.

    """
    assert vehicle._vehicle.mav.set_mode_send.call_args[0][2] == mode_id


def test_navigation_mode_methods(connected_vehicle_link):
    """
    Tests the navigation mode related methods in various scenarios.

    Test scenarios:
    ---------------

    1.  Before any other call, state.navigation_mode should be MANUAL
        and both is_stabilize_mode_on() and is_depth_hold_mode_on()
        should be False.
    2.  After start_stabilize_mode(), state.navigation_mode should be
        STABILIZE, is_stabilize_mode_on() should be True and
        is_depth_hold_mode_on() should be False. Moreover, mavlink
        set_mode_send() must have been called with id 0.
    3.  After stop_stabilize_mode(), state.navigation_mode should be
        MANUAL and both is_stabilize_mode_on() and
        is_depth_hold_mode_on() should be False. Moreover, mavlink
        set_mode_send() must have been called with id 19.
    4.  After start_depth_hold_mode(), state.navigation_mode should be
        DEPTH_HOLD, is_depth_hold_mode_on() should be True and
        is_stabilize_mode_on() should be False. Moreover, mavlink
        set_mode_send() must have been called with id 2.
    5.  After stop_depth_hold_mode(), state.navigation_mode should be
        MANUAL and both is_stabilize_mode_on() and
        is_depth_hold_mode_on() should be False. Moreover, mavlink
        set_mode_send() must have been called with id 19.

    Parameters
    ----------
    connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle = connected_vehicle_link[0]
    with patch.object(vehicle._vehicle, 'mode_mapping') as mapping_mock:
        mapping_mock.return_value = dict(
            (a, b) for (b, a) in mavutil.mode_mapping_sub.items())
        assert vehicle.state.navigation_mode\
            == VehicleNavigationMode.MANUAL
        assert not vehicle.is_stabilize_mode_on()
        assert not vehicle.is_depth_hold_mode_on()
        vehicle.start_stabilize_mode()  # STABILIZE: 0
        assert_set_mode_with_id(vehicle, 0)
        assert vehicle.state.navigation_mode\
            == VehicleNavigationMode.STABILIZE
        assert vehicle.is_stabilize_mode_on()
        assert not vehicle.is_depth_hold_mode_on()
        vehicle.stop_stabilize_mode()  # MANUAL: 19
        assert_set_mode_with_id(vehicle, 19)
        assert vehicle.state.navigation_mode\
            == VehicleNavigationMode.MANUAL
        assert not vehicle.is_stabilize_mode_on()
        assert not vehicle.is_depth_hold_mode_on()
        vehicle.start_depth_hold_mode()  # DEPTH_HOLD: 2
        assert_set_mode_with_id(vehicle, 2)
        assert vehicle.state.navigation_mode\
            == VehicleNavigationMode.DEPTH_HOLD
        assert not vehicle.is_stabilize_mode_on()
        assert vehicle.is_depth_hold_mode_on()
        vehicle.stop_depth_hold_mode()  # MANUAL: 19
        assert_set_mode_with_id(vehicle, 19)
        assert vehicle.state.navigation_mode\
            == VehicleNavigationMode.MANUAL
        assert not vehicle.is_stabilize_mode_on()
        assert not vehicle.is_depth_hold_mode_on()
        vehicle.set_navigation_mode(VehicleNavigationMode.STABILIZE)
        assert vehicle.state.navigation_mode == VehicleNavigationMode.STABILIZE
        with pytest.raises(TypeError):
            vehicle.set_navigation_mode(True)
            vehicle.set_navigation_mode(1)


def assert_mavlink_arm_call(vehicle):
    """
    Assertion of "arm" call.

    Parameters
    ----------
    vehicle : MavlinkVehicleLink
        Patched MavlinkVehicleLink object

    """
    assert vehicle._vehicle.mav.command_long_send.call_args[0][4] == 1


def assert_mavlink_disarm_call(vehicle):
    """
    Assertion of "disarm" call.

    Parameters
    ----------
    vehicle : MavlinkVehicleLink
        Patched MavlinkVehicleLink object

    """
    assert vehicle._vehicle.mav.command_long_send.call_args[0][4] == 0

def test_arming_methods(connected_vehicle_link):
    """
    Tests the arm/disarm related methods in various scenarios.

    Test scenarios:
    ---------------

    1.  Before any other call, both is_armed() and state.armed should be
        False.
    2.  After calling toggle_armed(), both is_armed() and state.armed
        should be True. Moreover, command_long_send() must have been
        called to arm (fourth arg: 1).
    3.  After calling toggle_armed() again, both is_armed() and
        state.armed should be False. Moreover, command_long_send() must
        have been called to disarm (fourth arg: 0).
    4.  After calling do_arm(), both is_armed() and state.armed
        should be True. Moreover, command_long_send() must have been
        called to arm (fourth arg: 1).
    5.  After calling do_disarm(), both is_armed() and state.armed
        should be False. Moreover, command_long_send() must have been
        called to disarm (fourth arg: 0).

    Parameters
    ----------
    connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle = connected_vehicle_link[0]
    assert not vehicle.is_armed()
    assert not vehicle.state.armed
    vehicle.toggle_armed()
    assert_mavlink_arm_call(vehicle)
    assert vehicle.is_armed()
    assert vehicle.state.armed
    vehicle.toggle_armed()
    assert_mavlink_disarm_call(vehicle)
    assert not vehicle.is_armed()
    assert not vehicle.state.armed
    vehicle.do_arm()
    assert_mavlink_arm_call(vehicle)
    assert vehicle.is_armed()
    assert vehicle.state.armed
    vehicle.do_disarm()
    assert_mavlink_disarm_call(vehicle)
    assert not vehicle.is_armed()
    assert not vehicle.state.armed


def assert_mavlink_override_rc_call(vehicle, channel, pwm_value,
                                    method_name, input_args):
    """
    Assertion of rc_channels_override_send calls.

    Asserts the last rc_channels_override_send, checking that the
    channel and the pwm value fits the expected call, giving a nice
    message in case of failure.

    Parameters
    ----------
    vehicle : MavlinkVehicleLink
        Patched MavlinkVehicleLink object
    channel : int
        Expected pwm channel
    pwm_value : int
        Expected pwm value
    method_name : str
        Name of the original method that caused the rc_channels_override
        call.
    input_args : tuple
        The arguments that have been passed to the original method.

    """
    assert vehicle._vehicle.mav.\
        rc_channels_override_send.call_args[0][channel + 1] == pwm_value,\
        "Overriding RC Channel {ch} with: {val} when calling "\
        "\"{method}{inputargs}\" (expected value was: {pwm})".format(
            ch=channel,
            val=vehicle._vehicle.mav.
            rc_channels_override_send.call_args[0][channel + 1],
            method=method_name,
            inputargs=input_args,
            pwm=pwm_value)


def test_movement_methods(connected_vehicle_link):
    """
    Tests the movement related methods in various scenarios.

    .. note::
        Every movement-related method has a similar signature (intensity
        as the first argument and a bool flag for the movement sense).
        So, every test scenario should be called for every movement
        method:
        -   turn_pitch()
        -   turn_roll()
        -   move_vertical()
        -   turn_yaw()
        -   move_horizontal()
        -   move_lateral()


    Test scenarios:
    ---------------

    1.  Calling with arguments of invalid type (should raise TypeError):
        -   intensity as str.
        -   flag as str.
        -   intensity as bool.
        -   flag as int.
    2.  Calling with arguments of invalid value (should raise
        ValueError):
        -   intensity > 100 (100.0001 and 120).
        -   intensity < 0 (-50 and -0.000001)
    3.  After that, a table of calculated intensity, flag to PWM values
        should be tested.
                    +-----------+-------+-------+
                    | Intensity |  Flag |  PWM  |
                    +===========+=======+=======+
                    |    100    |  True |   190 |
                    |     91    |  True |  1864 |
                    |     82    |  True |  1828 |
                    |     73    |  True |  1792 |
                    |     64    |  True |  1756 |
                    |     55    |  True |  1720 |
                    |     46    |  True |  1684 |
                    |     37    |  True |  1648 |
                    |     28    |  True |  1612 |
                    |     19    |  True |  1576 |
                    |     10    |  True |  1540 |
                    |      1    |  True |  1504 |
                    |    100    | False |  1100 |
                    |     91    | False |  1136 |
                    |     82    | False |  1172 |
                    |     73    | False |  1208 |
                    |     64    | False |  1244 |
                    |     55    | False |  1280 |
                    |     46    | False |  1316 |
                    |     37    | False |  1352 |
                    |     28    | False |  1388 |
                    |     19    | False |  1424 |
                    |     10    | False |  1460 |
                    |      1    | False |  1496 |
                    +-----------+-------+-------+
    4.  Finally, the stop_movement() method should generate a pwm value
        of 1500 on every movement channel.

    Parameters
    ----------
    connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle = connected_vehicle_link[0]
    test_methods = {  # Method: RC Channel
        vehicle.turn_pitch: 1,
        vehicle.turn_roll: 2,
        vehicle.move_vertical: 3,
        vehicle.turn_yaw: 4,
        vehicle.move_horizontal: 5,
        vehicle.move_lateral: 6
    }
    type_error_inputs = [('100', False), (100, 'True'),
                         (False, False), (100.0, 1)]
    value_error_inputs = [(100.0001, False), (-50, True),
                          (-0.000001, False), (120, True)]
    expected_rc_outputs = {
        (100, True): 1900, (100.0, False): 1100,
        (91, True): 1864, (91.0, False): 1136,
        (82, True): 1828, (82.0, False): 1172,
        (73, True): 1792, (73.0, False): 1208,
        (64, True): 1756, (64.0, False): 1244,
        (55, True): 1720, (55.0, False): 1280,
        (46, True): 1684, (46.0, False): 1316,
        (37, True): 1648, (37.0, False): 1352,
        (28, True): 1612, (28.0, False): 1388,
        (19, True): 1576, (19.0, False): 1424,
        (10, True): 1540, (10.0, False): 1460,
        (1, True): 1504, (1.0, False): 1496,
    }
    for method, channel in test_methods.items():
        # Test inapropiate types
        for inputs in type_error_inputs:
            with pytest.raises(TypeError):
                method(*inputs)
        # Test inapropiate values
        for inputs in value_error_inputs:
            with pytest.raises(ValueError):
                method(*inputs)
        # Test that appropiate inputs generate appropiate rc output
        for inputs, expected_output in expected_rc_outputs.items():
            method(*inputs)
            assert_mavlink_override_rc_call(vehicle, channel, expected_output,
                                            method.__name__, inputs)
    vehicle.stop_movement()
    for channel in range(1, 7):
        assert_mavlink_override_rc_call(vehicle, channel, 1500,
                                        'stop_movement', ())


def test_heartbeat_is_sent_every_second(connected_vehicle_link):
    """
    Tests if the heartbeat method is called every second.

    Also, checks if it's called with the right arguments.

    Parameters
    ----------
    connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle = connected_vehicle_link[0]
    initial_time = time()
    initial_heartbeat_count = vehicle._vehicle.mav.heartbeat_send.call_count
    heartbeats_elapsed = 0
    while heartbeats_elapsed == 0:
        heartbeats_elapsed = vehicle._vehicle.mav.heartbeat_send.call_count\
            - initial_heartbeat_count
        if time() - initial_time > 1.5:  # A second has elapsed
            break
        sleep(0.1)
    assert vehicle._vehicle.mav.\
        heartbeat_send.call_count > initial_heartbeat_count
    assert vehicle._vehicle.mav.\
        heartbeat_send.call_args[0] == (6, 8, 192, 0, 4, 3)
    # TODO: document why these input arguments are expected.


def test_input_gain_changed(connected_vehicle_link):
    """
    Tests if input_gain_changed() method is working.

    Parameters
    ----------
    connected_vehicle_link : tuple
        Test fixture. Elements:
        1.  MavlinkVehicleLink object, with a mock on the mavlink
            connection method.
        2.  The mock on the mavlink connection method. The return_value
            will be used to create a mocked mavlink object.
        3.  The mock on the recv_match() method. Using this mock the
            user can test different message types with different data.

    """
    vehicle = connected_vehicle_link[0]
    assert vehicle.state.input_gain == 0.5
    vehicle.input_gain_changed(0.2)
    assert vehicle.state.input_gain == 0.2


def test_auto_rearm(connected_vehicle_link):
    """TODO: Document."""
    vehicle = connected_vehicle_link[0]
    vehicle.do_arm()
    assert vehicle.state.armed
    with patch.object(vehicle, 'do_arm') as fake_arm:
        assert not fake_arm.called
        vehicle._do_process_data({'mavpackettype': 'HEARTBEAT',
                                  'base_mode': 0})
        assert fake_arm.called
